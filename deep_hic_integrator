#! /usr/bin/env python3
# -*- coding: utf-8 -*-

"""

    Integrative Deep-Learning Framework for Analyzing the Interplay between Chromatin Conformation
    and Epigenetics
    Autor: Hélène Kabbech
    Medical Center University of Göttingen (Germany), Institute of Pathologie, Papantonis Lab

    Usage:
        ./deep_hic_integrator <HIC_FILE> <CHROMHMM_FILE> [--hic_resolution INT]
                                                         [--chr_train INT]
                                                         [--chr_test INT]
                                                         [--alpha FLOAT]
                                                         [--square_side INT]
                                                         [--epochs INT]
                                                         [--batch_size INT]
                                                         [--output PATH]

    Arguments:
        <HIC_FILE>                          Path to the Hi-C matrix file (.hic format)
        <CHROMHMM_FILE>                     Path to the ChromHMM bed file

    Options:
        -r, INT, --hic_resolution INT       Hi-C matrix resolution to use. [default: 25000]
        -g INT, --chr_train INT             Chromosome used to train the autoencoder [default: 1]
        -t INT, --chr_test INT              Chromosome used to test [default: 20]
        -a FLOAT, --alpha FLOAT             Parameter alpha of the interpolation [default: 0.5]
        -n INT, --square_side INT           Size n*n of a sub-matrix [default: 60]
        -e INT, --epochs INT                Number of epochs [default: 50]
        -b INT, --batch_size INT            Size of a batch [default: 128]
        -o PATH, --output PATH              Output path [default: output/]
        -h, --help                          Show this

"""


# Third-party modules
from datetime import datetime
import os
import random as rd
from schema import Schema, And, Use, SchemaError
import numpy as np
from docopt import docopt
from matplotlib import cm
from matplotlib.colors import ListedColormap
import cooler
from hic2cool import hic2cool_convert


# Local modules
from src.hic import Hic
from src.chromhmm import ChromHMM
from src.predict_hic import PredictHic
from src.autoencoder import Autoencoder
from src.interpolation import Interpolation


def check_args(arguments):
    """
        Checks and validates the types of inputs parsed by docopt from command line.

        Args:
            arguments(class 'docopt.Dict'): The input arguments of the script
    """
    schema = Schema({
        '<HIC_FILE>': Use(open, error='HIC_FILE should be readable'),
        '<CHROMHMM_FILE>': Use(open, error='CHROMHMM_FILE should be readable'),
        '--hic_resolution': And(Use(int), lambda n: n%5000 == 0 and 5000 <= n <= 2500000,
                                error='--resolution should be between 5,000 and 2,500,000'),
        '--chr_train': And(Use(int), lambda n: 1 <= n <= 23,
                           error='--train shoud be integer 1<= N <= 23'),
        '--chr_test': And(Use(int), lambda n: 1 <= n <= 23,
                          error='--test shoud be integer 1<= N <= 23'),
        '--alpha': And(Use(float), lambda n: 0 < n < 1,
                       error='--alpha shoud be float 0< N < 1'),
        '--square_side': And(Use(int), lambda n: 1 <= n <= 210,
                             error='--square_side shoud be integer 1<= N <= 23'),
        '--epochs': And(Use(int), lambda n: 1 <= n <= 10000,
                        error='--epochs shoud be integer 1<= N <= 10000'),
        '--batch_size': And(Use(int), lambda n: n%16 == 0,
                            error='--batch_size : The rest of the division by 16 should be 0'),
        # The output PATH is created (if not exists) so we skip the check.
        object: object})
    try:
        schema.validate(arguments)
    except SchemaError as err:
        exit(err)

if __name__ == "__main__":

    START_TIME = datetime.now()

    ### PARSE COMMAND LINE
    ######################

    ARGS = docopt(__doc__)
    # Check the types and ranges of the command line arguments parsed by docopt
    check_args(ARGS)

    # Files :
    CHROMHMM_FILENAME = ARGS['<CHROMHMM_FILE>'] # File containing the ChromHMM file
    RESOLUTION = int(ARGS['--hic_resolution']) # Resolution of the Hi-C matrix
    HIC_FILENAME = ARGS['<HIC_FILE>'] # File containing the Hi-C matrix
    COOL_FILENAME = HIC_FILENAME.split('.hic')[0]+'_'+str(RESOLUTION)+'.cool'
    # Conversion from .hic to .cool
    if not os.path.exists(COOL_FILENAME):
        hic2cool_convert(HIC_FILENAME, COOL_FILENAME, RESOLUTION)

    # Parameters of the deep-learning framework :
    CHR_TRAIN = int(ARGS['--chr_train']) # Chromosome used to train the Autoencoder
    CHR_TEST = int(ARGS['--chr_test']) # Chromosome used to test
    N = int(ARGS['--square_side'])
    EPOCHS = int(ARGS['--epochs'])
    BATCH_SIZE = int(ARGS['--batch_size'])

    # Parameter for the interpolation :
    ALPHA = float(ARGS['--alpha'])

    # Output paths :
    MODEL_PATH = ARGS['--output']+'/model/'
    os.makedirs(MODEL_PATH, exist_ok=True)
    TEST_PATH = ARGS['--output']+'/test_chr'+str(CHR_TEST)+'/'
    os.makedirs(TEST_PATH, exist_ok=True)

    # Refine color map for the plots :
    RED_CMP = ListedColormap(np.vstack((np.array([1, 1, 1, 1]),
                                        cm.get_cmap('Reds', 300)(np.linspace(0, 1, 300)))))


    ### TRAINING OF THE AUTOENCODER
    ###############################

    TRAIN_HIC = Hic(cooler.Cooler(COOL_FILENAME), CHR_TRAIN, N)
    TRAIN_HIC.set_matrix()
    TRAIN_HIC.plot_matrix(RED_CMP, MODEL_PATH)
    TRAIN_HIC.set_sub_matrices()

    # TRAIN_CHROMHMM = ChromHMM(CHROMHMM_FILENAME, CHR_TRAIN)

    AE = Autoencoder(TRAIN_HIC, N, EPOCHS, BATCH_SIZE)
    AE.set_models()
    AE.compile()
    AE.train()
    AE.save_model(MODEL_PATH)
    AE.plot_loss_curve(MODEL_PATH)
    AE.plot_accuracy_curve(MODEL_PATH)


    ### TESTING OF THE AUTOENCODER
    ##############################

    TEST_HIC = PredictHic(cooler.Cooler(COOL_FILENAME), CHR_TEST, N)
    TEST_HIC.set_matrix()
    TEST_HIC.set_sub_matrices()
    TEST_HIC.set_predicted_sub_matrices(AE.cae.predict(TEST_HIC.sub_matrices))
    TEST_HIC.construct_predicted_matrix()
    TEST_HIC.write_predicted_matrix(0.1, TEST_PATH)

    # Plots
    RANDOM_INDEX_LIST = rd.sample(range(0, TEST_HIC.sub_matrices.shape[0]), 40)
    TEST_HIC.plot_sub_matrices(RED_CMP, TEST_PATH, RANDOM_INDEX_LIST)
    TEST_HIC.plot_predicted_sub_matrices(RED_CMP, TEST_PATH, RANDOM_INDEX_LIST)
    TEST_HIC.plot_matrix(RED_CMP, TEST_PATH)
    TEST_HIC.plot_predicted_matrix(RED_CMP, TEST_PATH)


    ### INTERPOLATION
    #################
    HIC_LATENT_SPACES = AE.encoder.predict(TEST_HIC.sub_matrices)
    PREDICTED_HIC = AE.decoder.predict(HIC_LATENT_SPACES)
    tmp = TEST_HIC.sub_matrices.copy()
    np.random.shuffle(tmp)
    CHROMHMM_LATENT_SPACES = AE.encoder.predict(tmp)
    PREDICTED_CHROMHMM = AE.decoder.predict(CHROMHMM_LATENT_SPACES)
    INTERPOLATION = Interpolation(ALPHA, HIC_LATENT_SPACES, PREDICTED_HIC,
                                  CHROMHMM_LATENT_SPACES, PREDICTED_CHROMHMM, AE.decoder)
    INTERPOLATION.interpolate_predicted_img()
    INTERPOLATION.interpolate_latent_spaces()
    INTERPOLATION.set_decoded_latent_spaces()
    INTERPOLATION.plot_random_interpolation(RED_CMP, N, TEST_PATH)
    INTERPOLATION.construct_predicted_matrix(TEST_HIC)

    ### SAVE PARAMETERS
    ###################

    TIME = datetime.now() - START_TIME

    # All the parameters of the training and testing parts are saved in a log file.
    with open(MODEL_PATH+'parameters.log', 'w') as file:
        file.write('Hi-C parameters:\n Resolution: {}\n Size sub-matrices: {}*{}\n\n'
                   .format(RESOLUTION, N, N))
        file.write('Train:\n Chromosome: {}\n Shape matrix: {}\n Shape sub_matrices: {}\n\n'
                   .format(TRAIN_HIC.chrom, TRAIN_HIC.matrix.shape, TRAIN_HIC.sub_matrices.shape))
        file.write('Test:\n Chromosome: {}\n Shape matrix: {}\n Shape sub_matrices: {}\n\n'
                   .format(TEST_HIC.chrom, TEST_HIC.matrix.shape, TEST_HIC.sub_matrices.shape))
        file.write('Autoencoder parameters:\n Epochs: {}\n Batch size: {}\n'
                   .format(EPOCHS, BATCH_SIZE))
        file.write(' Optimizer: {}\n Loss function: {}\n Metrics: {}\n\n'
                   .format(AE.cae.optimizer, AE.cae.loss, AE.cae.metrics))
        file.write('Running time: {}'.format(TIME))

    print("\nTotal runtime: {}h {}min".format(int(TIME.seconds/3600), int((TIME.seconds/3600-int(TIME.seconds/3600))*60)))
    #  TIME.microseconds
